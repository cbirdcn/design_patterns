## 适配器模式Adapter（为新接口加适配器，避免客户端改变调用方式）（别名：包装器Wrapper）

- 简介

外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

> https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/facade.html

> https://designpatternsphp.readthedocs.io/zh_CN/latest/Structural/Facade/README.html

- 结构

![image](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Facade.jpg)

- 特点
  - 为子系统的访问提供了一个简单而单一的入口。 -外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 
  - 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。

- 优点
  - 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。
  - 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
  - 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。
- 缺点
  - 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

- 扩展

  - 在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。
  - 不要通过继承一个外观类在子系统中加入新的行为
