## 观察者模式（发布-订阅模式）

- 简介

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标（发布者），而被通知的对象称为观察者（订阅者），一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。
> https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html

- 优点

表示层和数据逻辑分离，消息传递机制更稳定。在观察者和观察目标间简历了抽象的耦合，容易扩展代码。

- 缺点

如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到（广播）会花费很多时间。

- 场景

凡是涉及对象信息交互的场景都可以，比如团战队友牺牲广播给队友，完成一个任务获得活动A和活动B的两个奖励礼包

- 举例

假设有两个观察者同时受到某个事件中数据变化的影响，比如Exp+100后造成等级以及战斗力变更。

PublisherExp作为发布者，此发布者类需要维护一个观察者列表，支持增减观察者，保存可能涉及变更的数据。实例化一个发布者后，当调用了发布者的__set()方法改变了数据，就要立即以同步的方式向观察者列表中所有已添加的观察者发送数据变化。

观察者在在另一条时间线异步管理观察者的实例化和订阅、退订。当同步收到发布者的同步调用时，必须实现发布者调用的update()方法，通过update()传递来的参数得知数据变化，然后在观察者实力中做出具体逻辑操作，比如计算等级，计算战斗力。

当有新的观察者加入时，不需要改动其他观察者业务逻辑，只需要调用发布者实例的attach()，把自己加入到观察者列表中即可。

这是观察者有不同逻辑需要处理的demo。

类似地还可以把一个组队的多个人作为一个观察者模式，一个人发的消息要给到所有人。房间打麻将的四个人加入一个观察者模式，每个人打出的牌要同步所有人。