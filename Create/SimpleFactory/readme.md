## 简单工厂模式（静态工厂方法模式）

- 简介

考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。

在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
> https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html

将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。

在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可

要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

- 优点
  - 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
  - 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
  - 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。


表示层和数据逻辑分离，消息传递机制更稳定。在观察者和观察目标间简历了抽象的耦合，容易扩展代码。

- 缺点
  - 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
  - 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
  - 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
  - **简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。**

- 场景

工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。

客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

- demo说明

客户端想通过一个参数（数据库驱动名称）就获取到一个数据库连接实例，然后用这个实例调用getOne($sql)方法就拿到数据。

现在有一个抽象的品类class叫做DataBaseProduct，再有两个具体产品实现类，叫做Mysql和SqlServer类。他们都实现了抽象类要求的getOne()方法。

另外有一个工厂类DatabaseFactory，获取参数（数据库驱动名称），并返回具体产品实现类的实例。

这样再加上一个对客户端完全隐藏工厂类名字的Customer类。

就可以实现，new 一个Customer，提供一个数据库驱动名称给到customer。customer将参数给工厂类，工厂类实例化具体产品类，并返回给customer。这样customer就用一个参数就拿到了数据库连接实例，接下来直接getOne()就可以了。


- 其他举例

抽卡

假设有金币抽卡、钻石抽卡、每日免费抽卡等多种抽卡类型。他们自身都属于抽卡业务，但是实现不同，类名也不同。可以简化抽卡类型为1,2,3，这样每次new 一个Gacha类，就可以new GachaSimpleFactory(gacha_id)，就可以获取实例。

活动

活动需要有个活动管理类，列出所有活动类型，比如排名活动，充值活动等。可以用参数快速实例化。

切换连接

比如redis切库、切换缓存或db或内存等


建议：

只用switch case做类似Class的实例化