## 工厂方法模式（在简单工厂中插入一层工厂子类作为具体工厂）

- 简介

对简单工厂中的子类，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例

> https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html

工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式

工厂方法模式包含如下角色：

- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂

工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

![image](https://design-patterns.readthedocs.io/zh_CN/latest/_images/loger.jpg)


- 优点
  - 由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。多态是同一个接口，使用不同的实例而执行不同操作。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。

- 缺点
  - 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
  - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

- 场景

一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。

一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。

将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。这种情况相当于传参数，然后自动实例化参数对应的工厂子类，不需要改动代码，只需要配置文件有对应的工厂子类。


- demo说明

[源代码](https://learnku.com/docs/php-design-patterns/2018/FactoryMethod/1489)

产品类分成父产品接口LoggerProductInterface和具体产品实现类StdoutLoggerConcreteProduct和FileLoggerConcreteProduct。

两个具体产品实现类都要根据父接口要求的log($msg)方法，实现自己的逻辑。

LoggerParentFactory是父工厂接口，要求实现createLogger()，也就是实例化一个LoggerProduct。

StdoutLoggerChildFactory是子工厂，是父工厂的实现类。实现createLogger的过程是实例化一个对应的具体产品实例StdoutLoggerConcreteProduct。

FileLoggerChildFactory和StdoutLoggerChildFactory类似，都是子工厂。

需要客户端或配置文件能记住子工厂列表，实例化时需要调用子工厂的createLogger()方法得到一个具体产品的实例，然后调用log($msg)实现功能


- 其他举例

当具体产品有多种类型时，简单工厂可以用工厂方法模式替代。

> 抽卡

同样是抽卡，有金币抽卡、钻石抽卡、每日免费抽卡等多种抽卡类型。实现不同，类名也不同。

现在让他们都工厂化。

具体产品类实现自己的抽卡execure()方法，里面可以处理自己消耗的道具，得到的物品，记录不同的日志，处理不同的抽奖逻辑。

GachaFactory作为interface。每种抽卡类型都实现一种子工厂，比如CoinGachaFactory、DiamonGachaFactory、FreeGachaFactory

在不同抽奖调用中，就可以直接(new CoinGachaFactory())->createGacha()->execute()得到不同类型的抽卡结果了。

> 活动

活动类型一般在配置表或配置文件中。往往会利用活动id和活动type，有时还有活动index，唯一确定一个或一类活动。

这时，就可以通过传入参数，查看配置中这些参数对应的活动应该是哪种，直接实例化一个活动出来。

> 切换连接

redis切库、切换缓存或db或内存等同上，可以把驱动名，数据库名等当做配置参数


- 建议：

有多种子类时，工厂方法替换掉简单工厂。如果只有一种子类型，工厂方法就退化为简单工厂了。