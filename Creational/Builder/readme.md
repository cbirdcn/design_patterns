## 建造者模式（**生成器模式**，按步骤创建复杂对象）

- 简介

无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，**建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象**。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。

在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且**在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等**。

复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

> https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html

- 结构

建造者模式包含如下角色：

- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

![image](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg)

抽象建造者类中定义了产品的创建方法和返回方法;

建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象


- 优点
  - 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
  - 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
  - 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
  - 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。

- 缺点
  - 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
  - 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。


- 场景
  - 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
  - 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
  - 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。
  - 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

- 简化
  - 省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。
  - 省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色。


- demo说明

[源代码](https://learnku.com/docs/php-design-patterns/2018/Builder/1488)

构建一个完整的车辆，需要按步骤进行。并且每种车辆的步骤和需要的组件可能不同。但是对客户端来说，只想要知道具体建造者类名，然后用(new Director())->build($concreteBuilder)就拿到实例。

对Builder来说，Interface规定创建一个具体车辆建造者，必须实现不同的三个过程：创建实例、分步骤为实例设置属性、返回实例。这样Director才可以按照固定顺序创建实例，返回实例。

由于不同的ConcreteBuilder会调用不同的实现，比如卡车需要6个轮子，小汽车只要6个。所以对Interface的实现是不同的，甚至会调用到不同对象的构造过程，比如汽车需要普通引擎，客车可能会用到卡车引擎。

所以还需要提供产品和组件类。产品包括车辆、卡车、汽车。其中，卡车、汽车从车辆Vehicle抽象类继承，抽象类规定了必须实现setData()方法用于set属性。此外具体产品类可以实现自己的逻辑，比如卡车的addEngine()可以获取卡车引擎、6个轮子，汽车可以在addDoors()方法的实现中调用自身的addTruckLib()方法添加后备箱（因为BuilderInterface中没有要求实现后备箱方法，所以汽车后备箱需要在其他方法中调用）

- 其他举例

在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，创建npc，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。